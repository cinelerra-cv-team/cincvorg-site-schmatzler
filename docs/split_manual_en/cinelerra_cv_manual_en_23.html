<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on February, 4 2016 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Cinelerra CV Manual: 23. Plugin authoring</title>

<meta name="description" content="Cinelerra CV Manual: 23. Plugin authoring">
<meta name="keywords" content="Cinelerra CV Manual: 23. Plugin authoring">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_22.html#SEC322" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_24.html#SEC353" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<hr size="2">
<a name="Plugin-authoring"></a>
<a name="SEC333"></a>
<h1 class="chapter"> 23. Plugin authoring </h1>

<p>The plugin API in Cinelerra dates back to 1997, before the LADSPA and before
VST became popular.  It is fundamentally the same as it was in 1997, with minor
modifications to handle keyframes and GUI feedback.  The GUI is not abstracted
from the programmer.  This allows the programmer to use whatever toolkit they
want and allows more flexibility in appearance but it costs more.
</p>
<p>There are several types of plugins, each with a common procedure of
implementation and specific changes for that particular type.  The easiest way
to implement a plugin is to take the simplest existing one out of the group and
rename the symbols.
</p>

<hr size="6">
<a name="Introducing-the-pull-method"></a>
<a name="SEC334"></a>
<h2 class="section"> 23.1 Introducing the pull method </h2>

<p>Originally plugins were designed with the push method.  The push method is
intuitive and simple.  A source pushes data to a plugin, the plugin does math
operations on it, and the plugin pushes it to a destination.  For 6 years this
was the way all realtime plugins were driven internally but it did not allow you
to reduce the rate of playback in realtime.  While plugins can still be
designed as if they are pushing data, this is not the way they are processed
internally anymore.
</p>
<p>The latest evolution in Cinelerra's plugin design is the pull method.  The
rendering pipeline starts at the final output and the final steps in the
rendering pipeline are reading the data from disk.  Every step in the rendering
chain involves requesting data from the previous step.  When the rendering
pipeline eventually requests data from a plugin chain, each plugin requests
data from the plugin before it.
</p>
<p>This is less intuitive than the push method but is much more powerful.
Realtime plugins written using the pull method can not only change the rate data is
presented to the viewer but also the direction of playback.  The pull method also allows
plugins to take in data at a higher rate than they send it out.
</p>
<p>To get the power of rate independence, the pull method requires plugins to know
more about the data than they needed to under the push method.  Plugins need to
know what rate the project is at, what rate their output is supposed to be at
and what rate their input is supposed to be at.  These different data rates
have to be correlated for a plugin to configure itself properly.
</p>
<p>Keyframes for a plugin are stored relative to the project frame rate.  Queries
from a plugin for the current playback position are given relative to the
project frame rate.  If the plugin's output was requested to be at twice the
project frame rate, the positions need to be converted to the project rate for
keyframes to match up.  Two classes of data rates were created to handle this
problem.
</p>
<p>Rate conversions are done in terms of the <b>project rate</b> and the <b>requested
rate</b>.  The project rate is identical for all plugins.  It is determined by the
<b>settings-&gt;format</b> window.  The requested rate is determined by the
downstream plugin requesting data from the current plugin.  The requested rate
is arbitrary.  Exactly how to use these rates is described below.
</p>
<hr size="6">
<a name="Common-plugin-functions"></a>
<a name="SEC335"></a>
<h2 class="section"> 23.2 Common plugin functions </h2>

<p>All plugins inherit from a derivative of PluginClient.  This PluginClient
derivative implements most of the required methods in PluginClient, but users
must still define methods for PluginClient.  The most commonly used methods are
predefined in macros to reduce the typing yet still allow flexibility.
</p>
<p>The files they include depend on the plugin type.  Audio plugins include
<tt>`pluginaclient.h'</tt> and video plugins include <tt>`pluginvclient.h'</tt>.  They
inherit <b>PluginAClient</b> and <b>PluginVClient</b> respectively.
</p>
<p>Cinelerra instantiates all plugins at least twice when they are used in a
movie.  One instance is the GUI.  The other instance is the signal processor.
User input, through a complicated sequence, is propagated from the GUI instance
to the signal processor instance.  If the signal processor wants to alter the
GUI, it propagates data back to the GUI instance.  There are utility functions
for doing all this.
</p>
<p>All plugins define at least three objects:
</p>
<ul>
<li> <b>Processing object</b><br>
Contains pointers to all the other objects and performs the signal processing.
This object contains a number of queries to identify itself and is the object
you register to register the plugin.
</li><li> <b>User interface object</b><br>
This is defined according to the programmer's discretion.  It can either use
Cinelerra's toolkit or another toolkit.  It shows data on the screen and
collects parameters from the user.<br>
Using Cinelerra's toolkit, the only user interface object a developer needs to
worry about is the Window.  The window has pointers to a number of widgets, a
few initialization methods, and a back pointer to the plugin's processing
object.  The documentation refers to the usage of Cinelerra's toolkit.<br>
Depending on the user interface toolkit, a user interface thread may be created
to run the user interface asynchronous of everything else.  Synchronizing the
user interface to changes in the plugin's configuration is the most complicated
aspect of the plugin, so the user interface thread and object are heavily
supported by macros if you use Cinelerra's toolkit.
</li><li> <b>Configuration object</b><br>
This stores the user parameters and always needs interpolation, copying, and
comparison functions.  Macros for the plugin client automatically call
configuration methods to interpolate keyframes.
</li></ul>


<hr size="6">
<a name="The-processing-object"></a>
<a name="SEC336"></a>
<h3 class="subsection"> 23.2.1 The processing object </h3>

<p>Load up a simple plugin like gain to see what this object looks like.  The
processing object should inherit from the intended PluginClient derivative.
Its constructor should take a PluginServer argument.
</p><pre class="verbatim">MyPlugin(PluginServer *server);
</pre>
<p>In the implementation, the plugin must contain a registration line with the
name of the processing object like
</p><pre class="verbatim">REGISTER_PLUGIN(MyPlugin)
</pre>
<p>The constructor should contain
</p><pre class="verbatim">PLUGIN_CONSTRUCTOR_MACRO
</pre><p>to initialize the most common variables.
</p>
<p>The processing object should have a destructor containing
</p><pre class="verbatim">PLUGIN_DESTRUCTOR_MACRO
</pre><p>to delete the most common variables.
</p>
<p>Another function which is useful but not mandatory is
</p><pre class="verbatim">int is_multichannel();
</pre><p>It should return 1 if one instance of the plugin handles multiple tracks
simultaneously or 0 if one instance of the plugin only handles one track.  The
default is 0 if it is omitted.
</p>
<p>Multichannel plugins in their processing function should refer to a function
called <b>PluginClient::get_total_buffers()</b> to determine the number of
channels.
</p>
<p>To simplify the implementation of realtime plugins, a macro for commonly used
members has been created for the class header, taking the configuration object
and user interface thread object as arguments.  The macro definitions apply
mainly to realtime plugins and are not useful in non-realtime plugins.
Fortunately, non-realtime plugins are simpler.
</p><pre class="verbatim">PLUGIN_CLASS_MEMBERS(config_name, thread_name)
</pre>
<p>The commonly used members in PLUGIN_CLASS_MEMBERS are described below.
</p>
<p><b>int load_configuration();</b><br>
Loads the configuration based on surrounding keyframes and current position.<br>
The class definition for load_configuration should contain
</p><pre class="verbatim">LOAD_CONFIGURATION_MACRO(plugin_class, config_class)
</pre><p>to implement the default behavior for load_configuration.  This stores whatever
the current configuration is inside the plugin's configuration object and
returns 1 if the new configuration differs from the previous configuration.
The return value of load_configuration is used by another commonly used
function, update_gui to determine if the GUI really needs to be updated.<br>
The plugin's configuration object is always called <b>config</b> inside
PLUGIN_CLASS_MEMBERS.
</p>
<p><b>VFrame* new_picon();</b><br>
Creates a picon for display in the resource window.  Use
</p><pre class="verbatim">#include &quot;picon_png.h&quot;
NEW_PICON_MACRO(plugin_class)
</pre><p>to implement new_picon.  In addition, the user should create a
<tt>`picon_png.h'</tt> header file from a PNG image using <code>pngtoh</code>.
<code>pngtoh</code> is compiled in the <tt>`guicast/ARCH'</tt> directory.<br>
The source PNG image should be called <tt>`picon.png'</tt> and can be any format
supported by PNG.
</p>
<p><b>char* plugin_title();</b><br>
Returns a text string identifying the plugin in the resource window.  The
string has to be unique.
</p>
<p><b>void update_gui();</b><br>
Should first load the configuration, test for a return of 1, and then redraw
the GUI with the new parameters.  All the plugins using GuiCast have a format
like
</p><pre class="verbatim">    void MyPlugin::update_gui()
    {
        if(thread)
        {
        if(load_configuration())
        {
            thread-&gt;window-&gt;lock_window();
            // update widgets here
            thread-&gt;window-&gt;unlock_window();
        }
        }
    }
</pre><p>to handle concurrency and conditions of no GUI.
</p>
<p><b>int show_gui();</b><br>
Instantiate the GUI and switch the plugin to GUI mode.  This is implemented
with
</p><pre class="verbatim">SHOW_GUI_MACRO(plugin_class, thread_class)
</pre>
<p><b>int set_string();</b><br>
Changes the title of the GUI window to a certain string.  This is implemented
with
</p><pre class="verbatim">SET_STRING_MACRO(plugin_class)
</pre>
<p><b>void raise_window();</b><br>
Raises the GUI window to the top of the stack.  This is implemented with
</p><pre class="verbatim">RAISE_WINDOW_MACRO(plugin_class)
</pre>
<p>Important functions that the processing object must define are the functions which
load and save configuration data from keyframes.  These functions are called by
the macros so all you need to worry about is accessing the keyframe data.
</p><pre class="verbatim">void save_data(KeyFrame *keyframe);
void read_data(KeyFrame *keyframe);
</pre>
<p>The read data functions are only used in realtime plugins.  The read data
functions translate the plugin configuration between the KeyFrame argument and
the configuration object for the plugin.  The keyframes are stored on the
timeline and can change for every project.
</p>
<p>Use an object called <b>FileXML</b> to do the translation and some specific
commands to get the data out of the KeyFrame argument.  See any existing plugin
to see the usage of KeyFrame and FileXML.
</p><pre class="verbatim">int load_defaults();
int save_defaults();
</pre>
<p>The load defaults functions are used in realtime and non-realtime plugins.  The
load defaults functions translate the plugin configuration between a BC_Hash
object and the plugin's configuration.  The BC_Hash object stores
configurations in a discrete file on disk for each plugin but does not isolate
different configurations for different projects.
</p>
<p>The function overriding <b>load_defaults</b> also needs to create the BC_Hash
object.  See any existing plugin to see the usage of BC_Hash.
</p>
<p>Other standard members may be defined in the processing object, depending on
the plugin type.
</p>
<hr size="6">
<a name="The-configuration-object"></a>
<a name="SEC337"></a>
<h3 class="subsection"> 23.2.2 The configuration object </h3>

<p>The configuration object is critical for GUI updates, signal processing, and
default settings in realtime plugins.  Be aware it is not used in non-realtime
plugins.  The configuration object inherits from nothing and has no
dependancies.  It is merely a class containing three functions and variables
specific to the plugin's parameters.
</p>
<p>Usually the configuration object starts with the name of the plugin followed by
Config.
</p><pre class="verbatim">    class MyPluginConfig
    {
    public:
        MyPluginConfig();
</pre>
<p>Following the name of the configuration class, we put in three required
functions and the configuration variables.
</p><pre class="verbatim">        int equivalent(MyPluginConfig &amp;that);
        void copy_from(MyPluginConfig &amp;that);
        void interpolate(MyPluginConfig &amp;prev,
        MyPluginConfig &amp;next,
        int64_t prev_position,
        int64_t next_position,
        int64_t current_position);
        float parameter1;
        float parameter2;
        int parameter3;
    };
</pre>
<p>Now you must define the three functions.  <b>Equivalent</b> is called by
LOAD_CONFIGURATION_MACRO to determine if the local configuration parameters are
identical to the configuration parameters in the argument.  If equivalent
returns 0, the LOAD_CONFIGURATION_MACRO causes the GUI to redraw.  If
equivalent returns 1, the LOAD_CONFIGURATION_MACRO does not redraw the GUI.
</p>
<p>Then there is <b>copy_from</b> which transfers the configuration values from the
argument to the local variables.  This is once again used in
LOAD_CONFIGURATION_MACRO to store configurations in temporaries.  Once
LOAD_CONFIGURATION_MACRO has replicated the configuration, it loads a second
configuration.  Then it interpolates the two configurations to get the current
configuration.  The interpolation function performs the interpolation and
stores the result in the local variables.
</p>
<p>Normally the interpolate function calculates a previous and next fraction,
using the arguments.
</p><pre class="verbatim">    void MyPluginConfig::interpolate(MyPluginConfig &amp;prev,
        MyPluginConfig &amp;next,
        int64_t prev_position,
        int64_t next_position,
        int64_t current_position
    {
        double next_scale =
        (double)(current_position - prev_position)
        / (next_position - prev_position);
        double prev_scale =
        (double)(next_position - current_position) /
        (next_position - prev_position);
</pre>
<p>Then the fractions are applied to the previous and next configuration variables
to yield the current values.
</p><pre class="verbatim">        this-&gt;parameter1 =
        (float)(prev.parameter1 * prev_scale
        + next.parameter1 * next_scale);
        this-&gt;parameter2 =
        (float)(prev.parameter2 * prev_scale
        + next.parameter2 * next_scale);
        this-&gt;parameter3 =
        (int)(prev.parameter3 * prev_scale
        + next.parameter3 * next_scale);
    }
</pre>
<p>Alternatively you can copy the values from the previous configuration argument
if no interpolation is desired.
</p>
<p>This usage of the configuration object is the same in audio and video plugins.
In video playback, the interpolation function is called for every frame,
yielding smooth interpolation.  In audio playback, the interpolation function
is called only once for every console fragment and once every time the
insertion point moves.  This is good enough for updating the GUI while
selecting regions on the timeline but it may not be accurate enough for really
smooth rendering of the effect.
</p>
<p>For really smooth rendering of audio, you can still use load_configuration when
updating the GUI.  For process_buffer; however, ignore load_configuration and
write your own interpolation routine which loads all the keyframes in a console
fragment and interpolates every sample.  This would be really slow and hard to
debug, yielding improvement which may not be audible.  Then of course, every
country has its own weirdos.
</p>
<p>An easier way to get smoother interpolation is to reduce the console fragment
to 1 sample.  This would have to be rendered and played back with the console
fragment back over 2048 of course.  The GNU/Linux sound drivers can not play
fragments of 1 sample.
</p>
<hr size="6">
<a name="The-user-interface-object"></a>
<a name="SEC338"></a>
<h3 class="subsection"> 23.2.3 The user interface object </h3>

<p>The user interface object at the very least consists of a pointer to a window
and pointers to all the widgets in the window.  Using Cinelerra's toolkit, it
consists of a <b>BCWindow</b> derivative and a <b>Thread</b> derivative.  The Thread
derivative is declared in the plugin header using
</p><pre class="verbatim">PLUGIN_THREAD_HEADER(plugin_class, thread_class, window_class)
</pre>
<p>Then it is defined using
</p><pre class="verbatim">PLUGIN_THREAD_OBJECT(plugin_class, thread_class, window_class)
</pre>
<p>This, in combination with the SHOW_GUI macro does all the work in instantiating
the Window.  This two-class system is used in realtime plugins but not in
non-realtime plugins.  Non-realtime plugins create and destroy their GUI in their
<b>get_parameters</b> function and there is no need for a Thread.
</p>
<p>Now the window class must be declared in the plugin header.  It is easiest to
implement the window by copying an existing plugin and renaming the symbols.
The following is an outline of what happens.  The plugin header must declare
the window's constructor using the appropriate arguments.
</p><pre class="verbatim">    #include &quot;guicast.h&quot;
    class MyPluginWindow : public BC_Window
    {
    public:
        MyPluginWindow(MyPluginMain *plugin, int x, int y);
</pre>
<p>This becomes a window on the screen, positioned at x and y.
</p>
<p>It needs two methods
</p><pre class="verbatim">int create_objects();
int close_event();
</pre><p>and a back pointer to the plugin
</p><pre class="verbatim">MyPlugin *plugin;
</pre>
<p>The constructor's definition should contain extents and flags causing the
window to be hidden when first created.  The create_objects member puts widgets
in the window according to GuiCast's syntax.  A pointer to each widget which
you want to synchronize to a configuration parameter is stored in the window
class.  These are updated in the <b>update_gui</b> function you earlier defined
for the plugin.  The widgets are usually derivatives of a GuiCast widget and
they override functions in GuiCast to handle events.  Finally create_objects
calls
</p><pre class="verbatim">show_window();
flush();
</pre><p>to make the window appear all at once.
</p>
<p>The close_event member should be implemented using
</p><pre class="verbatim">WINDOW_CLOSE_EVENT(window_class)
</pre>
<p>Every widget in the GUI needs to detect when its value changes.  In GuiCast the
<b>handle_event</b> method is called whenever the value changes.  In
<b>handle_event</b>, the widget then needs to call
<b>plugin-&gt;send_configure_change()</b> to propagate the change to any copies of
the plugin which are processing data.
</p>
<hr size="6">
<a name="Realtime-plugins"></a>
<a name="SEC339"></a>
<h2 class="section"> 23.3 Realtime plugins </h2>

<p>Realtime plugins should use PLUGIN_CLASS_MEMBERS to define the basic set of
members in their headers.  All realtime plugins must define an <b>int
is_realtime()</b>
</p>
<p>member returning 1.  This causes a number of methods to be called during live
playback and the plugin to be usable on the timeline.
</p>
<p>Realtime plugins must override a member called <b>process_buffer</b>
</p>
<p>This function takes different arguments depending on if the plugin handles
video or audio.  See an existing plugin to find out which usage applies.
</p>
<p>The main features of the process_buffer function are a buffer to store the
output, the starting position of the output, and the requested output rate.
For audio, there is also a size argument for the number of samples.
</p>
<p>The starting position of the output buffer is the lowest numbered sample on the
timeline if playback is forward and the highest numbered sample on the timeline
if playback is reverse.  The direction of playback is determined by one of the
plugin queries described below.
</p>
<p>The position and size arguments are all relative to the frame rate and sample
rate passed to process_buffer.  This is the requested data rate and may not be
the same as the project data rate.
</p>
<p>The process_realtime function should start by calling <b>load_configuration</b>.
The LOAD_CONFIGURATION_MACRO returns 1 if the configuration changed.
</p>
<p>After determining the plugin's configuration, input media has to be loaded for
processing.  Call:
</p><pre class="verbatim">    read_frame(VFrame *buffer,
        int channel,
        int64_t start_position,
        double frame_rate)
or
    read_samples(double *buffer,
        int channel,
        int sample_rate,
        int64_t start_position,
        int64_t len)
</pre>
<p>to request input data from the object which comes before this plugin.  The read
function needs a buffer to store the input data in.  This can either be a
temporary you create in the plugin or the output buffer supplied to
process_buffer if you do not need a temporary.
</p>
<p>It also needs a set of position arguments to determine when you want to read
the data from.  The start position, rate, and len passed to a read function
need not be the same as the values received by the process_buffer function.
This way plugins can read data at a different rate than they output data.
</p>
<p>The channel argument is only meaningful if this is a multichannel plugin.  They
need to read data for each track in the get_total_buffers() value and process
all the tracks.  Single channel plugins should pass 0 for channel.
</p>
<p>Additional members are implemented to maintain configuration in realtime
plugins.  Some of these are also needed in non-realtime plugins.
</p>
<ul>
<li> <b>void read_data(KeyFrame *keyframe);</b><br>
Loads data from a keyframe into the plugin's configuration.  Inside the
keyframe is an XML string.  It is most easily parsed by creating a <b>FileXML</b>
object.  See an existing plugin to see how the read_data function is
implemented.<br>
Read data loads data out of the XML object and stores values in the plugin's
configuration object.  Since configuration objects vary from plugin to plugin,
these functions can not be automated.

</li><li> <b>void save_data(KeyFrame *keyframe);</b><br>
Saves data from the plugin's configuration to a keyframe.  Inside the keyframe
you will put an XML string which is normally created by a FileXML object.  See an
existing plugin to see how the save_data function is implemented.<br>
Save data saves data from the plugin's configuration object into the XML
object.

</li><li> <b>int load_defaults();</b><br>
Another way the plugin gets parameters is from a defaults file.  The load and
save defaults routines use a BC_Hash object to parse the defaults file.  The
defaults object is created in <b>load_defaults</b> and destroyed in the plugin's
destructor.  See an existing plugin to see how the BC_Hash object is used.

</li><li> <b>int save_defaults();</b><br>
Saves the configuration in the defaults object.
</li></ul>

<hr size="6">
<a name="Non_002drealtime-plugins"></a>
<a name="SEC340"></a>
<h2 class="section"> 23.4 Non-realtime plugins </h2>

<p>Some references for non-realtime plugins are <b>Normalize</b> for audio and
<b>Reframe</b> for video.
</p>
<p>Like realtime plugins, <b>load_defaults</b> and <b>save_defaults</b> must be
implemented.  In non-realtime plugins, these are not just used for default
parameters but to transfer values from the user interface to the signal
processor.  There does not need to be a configuration class in non-realtime
plugins.
</p>
<p>Unlike realtime plugins, the LOAD_CONFIGURATION_MACRO can not be used in the
plugin header.  Instead, the following methods must be defined.
</p>
<p>The non-realtime plugin should contain a pointer to a defaults object.
</p><pre class="verbatim">BC_Hash *defaults;
</pre><p>It should also have a pointer to a MainProgressBar.
</p><pre class="verbatim">MainProgressBar *progress;
</pre>
<p>The progress pointer allows non-realtime plugins to display their progress in
Cinelerra's main window.
</p>
<p>The constructor for a non-realtime plugin cannot use PLUGIN_CONSTRUCTOR_MACRO
but must call <b>load_defaults</b> directly.
</p>
<p>The destructor, likewise, must call <b>save_defaults</b> and <b>delete defaults</b>
directly instead of PLUGIN_DESTRUCTOR_MACRO.
</p>
<ul>
<li> <b>VFrame* new_picon();</b><br>
<b>char* plugin_title();</b><br>
The usage of these is the same as realtime plugins.

</li><li> <b>int is_realtime();</b><br>
This function must return 0 to indicate a non-realtime plugin.

</li><li> <b>int get_parameters();</b><br>
Here, the user should create a GUI, wait for the user to hit an OK button or a
cancel button, and store the parameters in plugin variables.  This routine must
return 0 for success and 1 for failure.  This way the user can cancel the
effect from the GUI.<br>
Unlike the realtime plugin, this GUI need not run asynchronously of the plugin.
It should block the get_parameters function until the user selects OK or
Cancel.

</li><li> <b>int load_defaults();</b><br>
This should create a defaults object and load parameters from the defaults
object into plugin variables.

</li><li> <b>int save_defaults();</b><br>
This should save plugin variables to the defaults object.

</li><li> <b>int start_loop();</b><br>
If <b>get_parameters</b> returned 0 for success, this is called once to give the
plugin a chance to initialize processing.  The plugin should instantiate the
progress object with a line like<br>
<code>progress = start_progress(&quot;MyPlugin progress...&quot;,</code><br>
<code>PluginClient::get_total_len());</code><br>
The usage of <b>start_progress</b> depends on whether the plugin is multichannel
or single channel.  If it is multichannel you always call start_progress.  If
it is single channel, you first need to know whether the progress bar has
already started in another instance of the plugin.<br>
If <b>PluginClient::interactive</b> is 1, you need to start the progress bar.  If
it is 0, the progress bar has already been started.<br>
The PluginClient defines <b>get_total_len()</b> and <b>get_source_start()</b> to
describe the timeline range to be processed.  The units are either samples or
frames and in the project rate.

</li><li> <b>int process_loop</b><br>
This is called repeatedly until the timeline range is processed.  It has either
a samples or frames buffer for output and a reference to write_length to store
the number of samples processed.  If this is an audio plugin, the user needs to
call <b>get_buffer_size()</b> to know how many samples the output buffer can hold.
<br>
The plugin must use <b>read_samples</b> or <b>read_frame</b> to read the input.
These functions are a bit different for a non realtime plugin than they are for
a realtime plugin.<br>
They take a buffer and a position relative to the start of the timeline, in the
timeline's rate.  Then you must process it and put the output in the buffer
argument to process_loop.  write_length should contain the number of samples
generated if it is audio.<br>
Finally, process_loop must test <b>PluginClient::interactive</b> and update the
progress bar if it is 1.<br>
<code>progress-&gt;update(total_written);</code><br>
returns 1 or 0 if the progress bar was cancelled.  If it is 1, process_loop
should return 1 to indicate a cancellation.  In addition to progress bar
cancellation, <b>process_loop</b> should return 1 when the entire timeline range
is processed.

</li><li> <b>int stop_loop();</b><br>
This is called after process_loop processes its last buffer.<br>
If PluginClient::is_interactive is 1, this should call <b>stop_progress</b> in the
progress bar pointer and delete the pointer.  Then it should delete any objects
it created for processing in <b>start_loop</b>.
</li></ul>

<hr size="6">
<a name="Audio-plugins"></a>
<a name="SEC341"></a>
<h2 class="section"> 23.5 Audio plugins </h2>

<p>The simplest audio plugin is Gain.  The processing object should include
<tt>`pluginaclient.h'</tt> and inherit from <b>PluginAClient</b>.  Realtime audio
plugins need to define
</p><pre class="verbatim">    int process_buffer(int64_t size,
        double **buffer,
        int64_t start_position,
        int sample_rate);
if it is multichannel or
    int process_buffer(int64_t size,
        double *buffer,
        int64_t start_position,
        int sample_rate);
</pre><p>if it is single channel.  These should return 0 on success and 1 on failure.
In the future, the return value may abort failed rendering.
</p>
<p>The processing function needs to request input samples with
</p><pre class="verbatim">    int read_samples(double *buffer,
        int channel,
        int sample_rate,
        int64_t start_position,
        int64_t len);
</pre><p>It always returns 0.  The user may specify any desired sample rate and start
position.
</p>
<p>Non-realtime audio plugins need to define
</p><pre class="verbatim">int process_loop(double *buffer, int64_t &amp;write_length);
for single channel or
int process_loop(double **buffers, int64_t &amp;write_length);
</pre><p>for multi channel.  Non realtime plugins use a different set of read_samples
functions to request input data.  These are fixed to the project sample rate.
</p>
<hr size="6">
<a name="Video-plugins"></a>
<a name="SEC342"></a>
<h2 class="section"> 23.6 Video plugins </h2>

<p>The simplest video plugin is Flip.  The processing object should include
<tt>`pluginvclient.h'</tt> and inherit from <b>PluginVClient</b>.  Realtime video
plugins need to define
</p><pre class="verbatim">    int process_buffer(VFrame **frame,
        int64_t start_position,
        double frame_rate);
</pre><p>if it is multichannel or
</p><pre class="verbatim">    int process_buffer(VFrame *frame,
        int64_t start_position,
        double frame_rate);
</pre><p>if it is single channel.
</p>
<p>The non-realtime video plugins need to define
</p><pre class="verbatim">int process_loop(VFrame *buffer);
for single channel or
int process_loop(VFrame **buffers);
</pre><p>for multi channel.  The amount of frames generated in a single process_loop is
always assumed to be 1, hence the lack of a write_length argument.  Returning 0
causes the rendering to continue.  Returning 1 causes the rendering to abort.
</p>
<p>A set of read_frame functions exist for requesting input frames in non-realtime
video plugins.  These are fixed to the project frame rate.
</p>
<hr size="6">
<a name="Transition-plugins"></a>
<a name="SEC343"></a>
<h2 class="section"> 23.7 Transition plugins </h2>

<p>The simplest video transition is <b>wipe</b> and the simplest audio transition is
<b>crossfade</b>.  These use a subset of the default class members of realtime
plugins, but so far no analogue to PLUGIN_CLASS_MEMBERS has been done for
transitions.
</p>
<p>The processing object for audio transitions still inherits from PluginAClient
and for video transitions it still inherits from PluginVClient.
</p>
<p>Transitions may or may not have a GUI.  If they have a GUI, they must also
manage a thread like realtime plugins.  Do this with the same
PLUGIN_THREAD_OBJECT and PLUGIN_THREAD_HEADER macros as realtime plugins.
Since there is only one keyframe in a transition, you do not need to worry about
updating the GUI from the processing object like you do in a realtime plugin.
</p>
<p>If the transition has a GUI, you can use PLUGIN_CONSTRUCTOR_MACRO and
PLUGIN_DESTRUCTOR_MACRO to initialize the processing object.  You will also need
a BC_Hash object and a Thread object for these macros.
</p>
<p>Since the GUI is optional, overwrite a function called <b>uses_gui()</b> to
signifiy whether or not the transition has a GUI.  Return 1 if it does and 0 if
it does not.
</p>
<p>Transitions need a <b>load_defaults</b> and <b>save_defaults</b> function so the
first time they are dropped on the timeline they will have useful settings.
</p>
<p>A <b>read_data</b> and <b>save_data</b> function takes over after insertion to access
data specific to each instance of the transition.
</p>
<p>The most important difference between transitions and realtime plugins is the
addition of an <b>is_transition</b> method to the processing object.
<b>is_transition</b> should return 1 to signify the plugin is a transition.
</p>
<p>Transitions process data in a <b>process_realtime</b> function.
</p><pre class="verbatim">    int process_realtime(VFrame *input,
        VFrame *output);
    int process_realtime(int64_t size,
        double *input_ptr,
        double *output_ptr);
</pre><p>The input argument to process_realtime is the data for the next edit.  The
output argument to process_realtime is the data for the previous edit.
</p>
<p>Routines exist for determining where you are relative to the transition's start
and end.
</p>
<ul>
<li>
<b>PluginClient::get_source_position()</b> - returns the current position since
the start of the transition of the lowest sample in the buffers.

</li><li>
<b>PluginClient::get_total_len()</b> - returns the integer length of the
transition.  The units are either samples or frames, in the data rate requested
by the first plugin.
</li></ul>

<p>Users should divide the source position by total length to get the fraction of
the transition the current <b>process_realtime</b> function is at.
</p>
<p>Transitions run in the data rate requested by the first plugin in the track.
This may be different than the project data rate.  Since process_realtime lacks
a rate argument, use <b>get_framerate()</b> or <b>get_samplerate</b> to get the
requested rate.
</p>
<hr size="6">
<a name="Plugin-GUI_0027s-which-update-during-playback"></a>
<a name="SEC344"></a>
<h2 class="section"> 23.8 Plugin GUI's which update during playback </h2>

<p>Effects like <b>Histogram</b> and <b>VideoScope</b> need to update the GUI during
playback to display information about the signal.  This is achieved with the
<b>send_render_gui</b> and <b>render_gui</b> methods.  Normally in process_buffer,
when the processing object wants to update the GUI it should call
<b>send_render_gui</b>.  This should only be called in process_buffer.
Send_render_gui goes through a search and eventually calls <b>render_gui</b> in
the GUI instance of the plugin.
</p>
<p>Render_gui should have a sequence like
</p><pre class="verbatim">    void MyPlugin::render_gui(void *data)
    {
        if(thread)
        {
        thread-&gt;window-&gt;lock_window();
        // update GUI here
        thread-&gt;window-&gt;unlock_window();
        }
    }
</pre>
<p>Send_render_gui and render_gui use one argument, a void pointer to transfer
information from the processing object to the GUI.  The user should typecast
this pointer into something useful.
</p>
<hr size="6">
<a name="Plugin-queries"></a>
<a name="SEC345"></a>
<h2 class="section"> 23.9 Plugin queries </h2>

<p>There are several useful queries in PluginClient which can be accessed from the
processing object.  Some of them have different meaning in realtime and
non-realtime mode.  They all give information about the operating system or the
project which can be used to improve the quality of the processing.
</p>

<hr size="6">
<a name="System-queries"></a>
<a name="SEC346"></a>
<h3 class="subsection"> 23.9.1 System queries </h3>

<ul>
<li> <b>get_interpolation_type()</b><br>
Returns the type of interpolation the user wants for all scaling operations.
This is a macro from overlayframe.inc.  It can be applied to any call to the
<b>OverlayFrame</b> object.

</li><li> <b>get_project_smp()</b><br>
Gives the number of CPU's on the system minus 1.  If it is a uniprocessor it is
0.  If it is a dual processor, it is 1.  This number should be used to gain
parallelism.

</li><li> <b>get_total_buffers()</b><br>
Gives the number of tracks a multichannel plugin needs to process.
</li></ul>

<hr size="6">
<a name="Timing-queries"></a>
<a name="SEC347"></a>
<h3 class="subsection"> 23.9.2 Timing queries </h3>

<p>There are two rates for media a realtime plugin has to be aware of: the project
rate and the requested rate.  Functions are provided for getting the project
and requested rate.  In addition, doing time dependent effects requires using
several functions which tell where you are in the effect.
</p>
<ul>
<li> <b>get_project_framerate()</b><br>
Gives the frames per second of the video as defined by the project settings.

</li><li> <b>get_project_samplerate()</b><br>
Gives the samples per second of the audio as defined by the project settings.

</li><li> <b>get_framerate()</b><br>
Gives the frames per second requested by the plugin after this one.  This is
the requested frame rate and is the same as the frame_rate argument to
process_buffer.

</li><li> <b>get_samplerate()</b><br>
Gives the samples per second requested by the plugin after this one.  This is
the requested sample rate and is the same as the sample_rate argument to
process_buffer.

</li><li> <b>get_total_len()</b><br>
Gives the number of samples or frames in the range covered by the effect,
relative to the requested data rate.

</li><li> <b>get_source_start()</b><br>
For realtime plugins it gives the lowest sample or frame in the effect range in
the requested data rate.  For non-realtime plugins it is the start of the range
of the timeline to process.

</li><li> <b>get_source_position()</b><br>
For realtime plugins it is the lowest numbered sample in the requested region
to process if playing forward and the highest numbered sample in the region if
playing backward.  For video it is the start of the frame if playing forward
and the end of the frame if playing in reverse.  The position is relative to
the start of the EDL and in the requested data rate.<br>
For transitions this is always the lowest numbered sample of the region to
process relative to the start of the transition.

</li><li> <b>get_direction()</b><br>
Gives the direction of the current playback operation.  This is a macro defined
in transportque.inc.  This is useful for calling read functions since the read
functions position themselves at the start or end of the region to read,
depending on the playback operation.

</li><li> <b>local_to_edl()</b><br>
<b>edl_to_local()</b><br>
These convert between the requested data rate and the project data rate.  They
are used to convert keyframe positions into numbers which can be interpolated
at the requested data rate.  The conversion is automatically based on frame
rate or sample rate depending on the type of plugin.

</li><li> <b>get_prev_keyframe(int64_t position, int is_local)</b><br>
<b>get_next_keyframe(int64_t position, int is_local)</b><br>
These give the nearest keyframe before or after the position given.  The macro
defined version of load_configuration automatically retrieves the right
keyframes but you may want to do this on your own.<br>
The position argument can be either in the project rate or the requested rate.
Set is_local to 1 if it is in the requested rate and 0 if it is in the project
rate.<br>
In each keyframe, another position value tells the keyframe's position relative
to the start of the timeline and in the project rate.<br>
The only way to get smooth interpolation between keyframes is to convert the
positions in the keyframe objects to the requested rate.  Do this by using
edl_to_local on the keyframe positions.
</li></ul>

<hr size="6">
<a name="Using-OpenGL"></a>
<a name="SEC348"></a>
<h2 class="section"> 23.10 Using OpenGL </h2>

<p>Realtime video plugins support OpenGL.  Using OpenGL to do plugin routines can
speed up playback greatly since it does most of the work in hardware.
Unfortunately, every OpenGL routine needs a software counterpart for rendering,
doubling the amount of software to maintain.  Fortunately, having an OpenGL
routine means the software version does not need to be as optimized as it did
when software was the only way.
</p>
<p>As always, the best way to design a first OpenGL plugin is to copy an existing
one and alter it.  The <b>Brightness</b> plugin is a simple OpenGL plugin to copy.
There are 3 main points in OpenGL rendering and 1 point for optimizing OpenGL
rendering.
</p>

<hr size="6">
<a name="Getting-OpenGL-data"></a>
<a name="SEC349"></a>
<h3 class="subsection"> 23.10.1 Getting OpenGL data </h3>

<p>The first problem is getting OpenGL-enabled plugins to interact with
software-only plugins.  To solve this, all the information required to do
OpenGL playback is stored in the VFrame object which is passed to
<b>process_buffer</b>.  To support 3D, the VFrame contains a PBuffer and a
texture, in addition to VFrame's original rows.
</p>
<p>In OpenGL mode, VFrame has 3 states corresponding to the location of its video
data.  The opengl state is recovered by calling <b>get_opengl_state</b> and is set
by calling <b>set_opengl_state</b>.  The states are:
</p>
<ul>
<li> <b>VFrame::RAM</b><br>
This means the video data is stored in the traditional row pointers.  It must
be loaded into a texture before being drawn using OpenGL routines.

</li><li> <b>VFrame::TEXTURE</b><br>
The video data is stored in texture memory.  It is ready to be drawn using
OpenGL routines.

</li><li> <b>VFrame::SCREEN</b><br>
The video data is stored in a frame buffer in the graphics card.  For plugins,
the frame buffer is always a PBuffer.  The image on the frame buffer can not be
replicated again unless it is read back into the texture and the opengl state
is reset to TEXTURE.  The frame buffer is limited to 8 bits per channel.  If
an OpenGL effect is used in a floating point project, it only retains 8 bits.
</li></ul>

<p>In the plugin's <b>process_buffer</b> routine, there is normally a call to
<b>read_frame</b> to get data from the previous plugin in the chain.
<b>read_frame</b> takes a new parameter called <b>use_opengl</b>.
</p>
<p>The plugin passes 1 to <b>use_opengl</b> if it intends to handle the data using
OpenGL.  It passes 0 to <b>use_opengl</b> if it can only handle the data using
software.  The value of <b>use_opengl</b> is passed up the chain to ensure a
plugin which only does software only gets the data in the row pointers.  If
<b>use_opengl</b> is 0, the opengl state in VFrame is RAM.
</p>
<p>The plugin must not only know if it is software-only but if its output must be
software only.  Call <b>get_use_opengl</b> to determine if the output can be
handled by OpenGL.  If <b>get_use_opengl</b> returns 0, the plugin must pass 0 for
<b>use_opengl</b> in <b>read_frame</b> and do its processing in software.  If
<b>get_use_opengl</b> is 1, the plugin can decide based on its implementation
whether to use OpenGL.
</p>
<p>The main problem with OpenGL is that all the gl... calls need to be run from
the same thread.  To work around this, the plugin interface has routines for
running OpenGL in a common thread.
</p>
<p><b>run_opengl</b> transfers control to the common OpenGL thread.  This is normally
called by the plugin in <b>process_buffer</b> after it calls <b>read_frame</b> and
only if <b>get_use_opengl</b> is 1.
</p>
<p>Through a series of indirections, <b>run_opengl</b> eventually transfers control
to a virtual function called <b>handle_opengl</b>.  <b>handle_opengl</b> must be
overridden with a function to perform all the OpenGL routines.  The contents of
<b>handle_opengl</b> must be enclosed in <b>#ifdef HAVE_GL</b> ... <b>#endif</b> to
allow it to be compiled on systems with no graphics support, like render nodes.
The return value of <b>handle_opengl</b> is passed back from <b>run_opengl</b>.
</p>
<p><b>read_frame</b> can not be called from inside <b>handle_opengl</b>.  This would
create a recursive lockup because it would cause other objects to call
<b>run_opengl</b>.
</p>
<p>Once inside <b>handle_opengl</b>, the plugin has full usage of all the OpenGL
features.  VFrame provides some functions to automate common OpenGL sequences.
</p>
<p>The VFrame argument to <b>process_buffer</b> is always available through the
<b>get_output(int layer)</b> function.  If the plugin is multichannel, the layer
argument retrieves a specific layer of the output buffers.  The PBuffer of the
output buffer is where the OpenGL output must go if any processing is done.
</p>
<hr size="6">
<a name="Drawing-using-OpenGL"></a>
<a name="SEC350"></a>
<h3 class="subsection"> 23.10.2 Drawing using OpenGL </h3>

<p>The sequence of commands to draw on the output PBuffer stars with getting the
video in a memory area where it can be recalled for drawing:
</p><pre class="verbatim">get_output()-&gt;to_texture();
get_output()-&gt;enable_opengl();
</pre>
<ul>
<li> <b>to_texture</b> transfers the OpenGL data from wherever it is to the
output's texture memory and sets the output state to TEXTURE.
</li><li> <b>enable_opengl</b> makes the OpenGL context relative to the output's
PBuffer.
</li></ul>

<p>The next step is to draw the texture with some processing on the PBuffer.  The
normal sequence of commands to draw a texture is:
</p><pre class="verbatim">get_output()-&gt;init_screen();
get_output()-&gt;bind_texture(0);
get_output()-&gt;draw_texture();
</pre>
<ul>
<li> <b>VFrame::init_screen</b> sets the OpenGL frustum and parameters to known
values.
</li><li> <b>VFrame::bind_texture(int texture_unit)</b> binds the texture to the given
texture unit and enables it.
</li><li> <b>VFrame::draw_texture()</b> calls the vertex functions to draw the texture
normalized to the size of the PBuffer.  Copy this if you want custom vertices.
</li></ul>

<p>The last step in the handle_opengl routine, after the texture has been drawn on
the PBuffer, is to set the output's opengl state to SCREEN with a call to
<b>VFrame::set_opengl_state</b>.  The plugin should not read back the frame buffer
into a texture or row pointers if it has no further processing.  Plugins should
only leave the output in the texture or RAM if its location results from normal
processing.  They should set the opengl state to RAM or TEXTURE if they do.
</p>
<p><b>Colormodels in OpenGL:</b><br>
The colormodel exposed to OpenGL routines is always floating point since that
is what OpenGL uses, but it may be YUV or RGB depending on the project
settings.  If it is YUV, it is offset by 0.5 just like in software.  Passing
YUV colormodels to plugins was necessary for speed.  The other option was to
convert YUV to RGB in the first step that needed OpenGL.  Every effect and
rendering step would have needed a YUV to RGB routine.  With the YUV retained,
only the final compositing step needs a YUV to RGB routine.
</p>
<hr size="6">
<a name="Using-shaders"></a>
<a name="SEC351"></a>
<h3 class="subsection"> 23.10.3 Using shaders </h3>

<p>Very few effects can do anything useful with just a straight drawing of the
texture on the PBuffer.  They normally define a shader.  The shader is a C
program which runs on the graphics card.  Since the graphics card is optimized
for graphics, it can be much faster than running it on the CPU.
</p>
<p>Shaders are written in OpenGL Shading Language.  The shader source code is
contained in a string.  The normal sequence for using a shader comes after a
call to <b>enable_opengl</b>.
</p>
<pre class="verbatim">char *shader_source = &quot;...&quot;;
unsigned char shader_id = VFrame::make_shader(0, shader_source, 0);
glUseProgram(shader_id);
// Set uniform variables using glUniform commands
</pre>
<p>The compilation and linking step for shaders is encapsulated by the
VFrame::make_shader command.  It returns a shader_id which can be passed to
OpenGL functions.  The first and last arguments must always by 0.  And
arbitrary number of source strings may be put between the 0's.  The source
strings are concatenated by make_shader into one huge shader source.  If
multiple main functions are in the sources, the main functions are renamed and
run in order.
</p>
<p>There are a number of useful macros for shaders in <tt>`playback3d.h'</tt>.  All
the shaders so far have been fragment shaders.  After the shader is
initialized, draw the texture starting from <b>init_screen</b>.  The shader
program must be disabled with another call to <b>glUseProgram(0)</b> and 0 as the
argument.
</p>
<p>The shader_id and source code is stored in memory as long as Cinelerra runs.
Future calls to make_shader with the same source code run much faster.
</p>
<hr size="6">
<a name="Aggregating-plugins"></a>
<a name="SEC352"></a>
<h3 class="subsection"> 23.10.4 Aggregating plugins </h3>

<p>Further speed improvements may be obtained by combining OpenGL routines from
two plugins into a single handle_opengl function.  This is done when <b>Frame
to Fields</b> and <b>RGB to 601</b> are attached in order.  Aggregations of more than
two plugins are possible but very hard to get working.  Aggregation is useful
for OpenGL because each plugin must copy the video from a texture to a PBuffer.
In software there was no copy operation.
</p>
<p>In aggregation, one plugin processes everything from the other plugins and the
other plugins fall through.  The fall through plugins must copy their
parameters to the output buffer so they can be detected by the processing
plugin.
</p>
<p>The VFrame used as the output buffer contains a parameter table for parameter
passing between plugins and it is accessed with <b>get_output()-&gt;get_params()</b>.
Parameters are set and retrieved in the table with calls to <b>update</b> and
<b>get</b> just like with defaults.
</p>
<p>The fall through plugins must determine if the processor plugin is attached
with calls to <b>next_effect_is</b> and <b>prev_effect_is</b>.  These take the name
of the processor plugin as a string argument and return 1 if the next or
previous plugin is the processor plugin.  If either returns 1, the fall through
plugin must still call <b>read_frame</b> to propagate the data but return after
that.
</p>
<p>The processor plugin must call <b>next_effect_is</b> and <b>prev_effect_is</b> to
determine if it is aggregated with a fall through plugin.  If it is, it must
perform the operations of the fall through plugin in its OpenGL routine.  The
parameters for the the fall through plugin should be available by
<b>get_output()-&gt;get_params()</b> if the fall through plugin set them.
</p>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC333" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_24.html#SEC353" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated on <i>February, 4 2016</i> using <a href="http://texi2html.cvshome.org/"><i>texi2html 1.76</i></a>.
 </font>
 <br>

</p>
</body>
</html>
