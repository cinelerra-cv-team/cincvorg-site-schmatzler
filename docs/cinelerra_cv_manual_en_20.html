<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created on May 12, 2015 by texi2html 5.0
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>Cinelerra CV Manual: 20 Rendering files</title>

<meta name="description" content="Cinelerra CV Manual: 20 Rendering files">
<meta name="keywords" content="Cinelerra CV Manual: 20 Rendering files">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 5.0">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:pre}
span.nolinebreak {white-space:pre}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_19.html#Capturing-media" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_21.html#Tips" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<hr>
<a name="Rendering-files"></a>
<a name="Rendering-files-1"></a>
<h1 class="chapter">20 Rendering files</h1>
<a name="index-Rendering-files"></a>
<a name="index-Files_002c-rendering"></a>

<p>Rendering takes a section of the timeline, performs all the editing, effects
and compositing, and stores it in a pure movie file.  You can then delete all
the source assets, play the rendered file in a movie player, or bring it back
into Cinelerra for more editing.  It is very difficult to retouch any editing
decisions in the pure movie file, however, so keep the original assets and XML
file around several days after you render it.
</p>
<p>All rendering operations are based on a region of the timeline to be rendered.
You need to define this region on the timeline.  The navigation section
describes methods of defining regions.  See section <a href="cinelerra_cv_manual_en_13.html#Timebar">Timebar</a>.  The
rendering functions define the region based on a set of rules.  When a region
is highlighted or in/out points are set, the affected region is rendered.  When
no region is highlighted, everything after the insertion point is rendered.
Merely by positioning the insertion point at the beginning of a track and
unsetting all in/out points, the entire track is rendered.
</p>

<hr>
<a name="Single-file-rendering"></a>
<a name="Single-file-rendering-1"></a>
<h2 class="section">20.1 Single file rendering</h2>
<a name="index-Single-file-rendering"></a>

<p>The fastest way to get media to disk is to use the single file rendering
function.
</p>
<p>Go to <b>File-&gt;render</b> or press <kbd>SHIFT-R</kbd> to bring up the render dialog.
Select the magnifying glass <img src="manual_images_intl/magnify.png" alt="manual_images_intl/magnify"> to bring up a file
selection dialog.  This determines the filename to write the rendered file to
and the encoding parameters.
</p>
<img src="manual_images_intl/render_window.png" alt="manual_images_intl/render_window">
<p align="center"><b>The render window</b>
</p>
<p>In the render dialog select a format from the <b>File Format</b> menu.  The format
of the file determines whether you can render audio or video or both.  Select
the <b>Render audio tracks</b> toggle to generate audio tracks and <b>Render video
tracks</b> to generate video tracks.
</p>
<p>Select the wrench <img src="manual_images_intl/wrench.png" alt="manual_images_intl/wrench"> next to each toggle to set
compression parameters.  If the file format can not store audio or video the
compression parameters will be blank.  If <b>Render audio tracks</b> or <b>Render
video tracks</b> is selected and the file format does not support it, trying to
render will pop up an error.
</p>
<hr>
<a name="Separate-files-rendering"></a>
<a name="Separate-files-rendering-1"></a>
<h2 class="section">20.2 Separate files rendering</h2>
<a name="index-Separate-files-rendering"></a>

<p>The <b>Create new file at each label</b> option causes a new file to be created
when every label in the timeline is encountered.  This is useful for dividing
long audio recordings into individual tracks.  When using the renderfarm,
<b>Create new file at each label</b> causes one renderfarm job to be created at
every label instead of using the internal load balancing algorithm to space
jobs.
</p>
<p>When <b>Create new file at each label</b> is selected, a new filename is created
for every output file.  If the filename given in the render dialog has a 2
digit number in it, the 2 digit number is overwritten with a different
incremental number for every output file.  If no 2 digit number is given,
Cinelerra automatically concatenates a number to the end of the given filename
for every output file.
</p>
<p>In the filename &lsquo;<tt>/hmov/track01.wav</tt>&rsquo; the &lsquo;<samp>01</samp>&rsquo; would be overwritten for
every output file.  The filename &lsquo;<tt>/hmov/track.wav</tt>&rsquo;; however, would become
&lsquo;<tt>/hmov/track.wav001</tt>&rsquo; and so on and so forth.  Filename regeneration is
only used when either renderfarm mode is active or creating new files for every
label is active.
</p>
<hr>
<a name="Insertion-strategy-of-rendered-files"></a>
<a name="Insertion-strategy-of-rendered-files-1"></a>
<h2 class="section">20.3 Insertion strategy of rendered files</h2>
<a name="index-Insertion-strategy-of-rendered-files"></a>

<p>Finally the render dialog lets you select an insertion mode.  The insertion
modes are the same as with loading files.  In this case if you select <b>insert
nothing</b> the file will be written out to disk without changing the current
project.  For other insertion strategies be sure to prepare the timeline to
have the output inserted at the right position before the rendering operation
is finished.  See section <a href="cinelerra_cv_manual_en_7.html#Editing">Editing</a>.  Editing describes how to cause output to be
inserted at the right position.
</p>
<p>It should be noted that even if you only have audio or only have video
rendered, a <b>paste</b> insertion strategy will behave like a normal paste
operation, erasing any selected region of the timeline and pasting just the
data that was rendered.  If you render only audio and have some video tracks
armed, the video tracks will get truncated while the audio output is pasted
into the audio tracks.
</p>
<hr>
<a name="Batch-rendering"></a>
<a name="Batch-rendering-1"></a>
<h2 class="section">20.4 Batch rendering</h2>
<a name="index-Batch-rendering"></a>

<p>Batch Rendering is one of Cinelerra&rsquo;s great but lesser-known strengths. 
It allows you to eliminate manual repetitive keystrokes and mouse clicks, 
and automate the rendering of audio-video files. 
It even allows for Cinelerra to be completely driven by external programs, 
with no need for the user to manually interact with the Cinelerra user interface.
</p>
<p>If you want to render many projects to media files without having to repeatedly
attend to the <b>Render</b> dialog, <b>batch rendering</b> is the function to use.
In this function, you specify one or more Cinelerra project XML files (EDL) 
to render and the unique output files for each.  
Then Cinelerra loads each project file and renders it automatically, without any 
user intervention.  Each Cinelerra project XML file, combined with the settings 
for rendering an output file, are called a <b>batch</b>.  This allows a huge amount of media to be
processed and greatly increases the value of an expensive computer.
</p>
<p>The first thing to do when preparing to do batch rendering is to create one or 
more Cinelerra projects (EDL) to be rendered and save them as normal Cinelerra project 
(&lsquo;<tt>myproject.cin.xml</tt>&rsquo;) files. The batch renderer requires a separate Cinelerra
project file for every batch to be rendered. You can use the same Cinelerra project 
file if you are rendering to different output files, for example, 
creating the same output video in different file formats.  
</p>
<p>To create a Cinelerra project file which can be used in batch render, set up a
Cinelerra project and define the region to be rendered either by highlighting it, 
setting in/out points around it, or positioning the insertion point before it. 
Then save the project in the normal way to a &lsquo;<tt>myproject.cin.xml</tt>&rsquo; file (EDL). 
Define as many projects as needed this way.  
The batch renderer takes the active region from the EDL file for rendering.
</p>
<p>With all the Cinelerra project files (EDL) prepared with active regions, go to <b>File-&gt;batch
render</b>.  This brings up the batch rendering dialog.  The interface for batch
rendering is a bit more complex than for single file rendering.
</p>
<p>A list of batches must be defined before starting a batch rendering operation.
The table of batches appears on the bottom of the batch render dialog and is
called <b>batches to render</b>.  Above this are the configuration parameters for
a single batch.<br>
A batch is simply a pairing of a Cinelerra project file with a choice of output 
file and render settings.
</p>
<p>Set the <b>output path</b>, <b>file format</b>, <b>Audio</b>, <b>Video</b>, and <b>Create
new file at each label</b> parameters as if you were rendering a single file.  These
parameters apply to only one batch.  In addition to the standard rendering
parameters, you must select the Cinelerra project file (&lsquo;<tt>myproject.cin.xml</tt>&rsquo;) to be 
used in the batch. Do this by setting the <b>EDL path</b>. Use the magnifier to
bring a drop down menu with your files or write manually the path to your regular 
Cinelerra project file (&lsquo;<tt>myproject.cin.xml</tt>&rsquo;). In this case, <b>EDL path</b> has
nothing to do with EDL files as created by <b>File/Export EDL</b>.<br>
Cinelerra in batch render mode will not overwrite an existing output file. 
The batch render will simply fail. Make sure that no files with the same name as 
the output files exist before starting the render.<br>
</p>
<p>If the <b>batches to render</b> list is empty or nothing is highlighted, click
<b>New</b> to create a new batch.  The new batch will contain all the parameters
you just set.<br>
Repeatedly press the <b>New</b> button to create more batches with the same
parameters.  Highlight any batch and edit the configuration on the top of the
batch render window.  The highlighted batch is always synchronized to the
information displayed.<br>
Click and drag batches to change the order in which they are rendered.  Hit
<b>delete</b> to permanently remove the highlighted batch.<br>
In the list box is a column which enables or disables the batch.  This way
batches can be skipped without being deleted.  Click on the <b>Enabled</b> column
in the list box to enable or disable a batch.  If it is checked, the batch is
rendered.  If it is blank, the batch is skipped.
</p>
<p>The other columns in the batch list are informative.
</p><ul>
<li> <b>Output</b> The output path of the batch.
<a name="index-EDL-1"></a>
</li><li> <b>EDL</b> The source EDL of the batch.
</li><li> <b>Elapsed</b> The amount of time taken to render the batch if it is
finished.
</li></ul>

<p>To start rendering from the first enabled batch, hit <b>Start</b>.<br>
Once rendering, the main window shows the progress of the batch.  Once the
batch finishes, the elapsed column in the batch list is updated and the next
batch is rendered until all the enabled batches are finished.  The currently
rendering batch is always highlighted red.<br>
To stop rendering before the batches are finished without closing the batch
render dialog, hit <b>Stop</b>.<br>
To stop rendering before the batches are finished and close the batch render
dialog, hit <b>Cancel</b>.<br>
To exit the batch render dialog whether or not anything is being rendered, hit
<b>Cancel</b>.<br>
</p>
<p>You can automate Cinelerra batch renders from other programs. In the Cinelerra 
batch render dialog, once you have created your list of batch render jobs, 
you can click the button <b>Save List</b> and choose a file to save your <b>batch
render list</b> to. We suggest you use a filename like &lsquo;<tt>myrenderlist.batchrender.cin.xml</tt>&rsquo;. 
Once you have created this file, you can start up a batch render without 
needing to interact with the Cinelerra user interface. From a shell prompt 
(or from a script, or other program), execute: <br>
<code>cinelerra -r myrenderlist.batchrender.cin.xml</code><br>
(changing &lsquo;<tt>myrenderlist.batchrender.cin.xml</tt>&rsquo; to whatever filename you chose for 
saving your batch render list).<br>
When invoked with these parameters, Cinelerra will start up and perform the rendering 
jobs in that list, without creating its usual windows.
</p>
<p>Programmers, please note: this is a powerful feature indeed. It means that if you can 
create valid Cinelerra project xml files and Cinelerra render list files from other 
programs (which requires just a small amount of skill with your favourite XML library), 
then you can gain full automated access to all of Cinelerra&rsquo;s functionality without 
needing to interact with the Cinelerra user interface. The possibilities for this 
are endless. You can leverage the power of Cinelerra and incorporate it into your own 
programs. It&rsquo;s a good idea if you can create simple Cinelerra project files and 
batch render files and study the XML format. By trial and error, you&rsquo;ll be able to 
generate valid Cinelerra xml files for projects and batch render lists, and thus 
create your own Cinelerra automation library in your favourite programming language.
</p>
<hr>
<a name="The-render-farm"></a>
<a name="The-render-farm-1"></a>
<h2 class="section">20.5 The render farm</h2>
<a name="index-Render-farm"></a>

<p>When bicubic interpolation and HDTV was first done on Cinelerra, the time
needed to produce the simplest output became unbearable even on the fastest
dual 1.7 GHz Xeon of the time.  Renderfarm support even in the simplest form
brings HDTV times back in line with SD while making SD faster than real-time.
</p>
<p>While the renderfarm interface is not spectacular, it is simple enough to use
inside an editing suite with less than a dozen nodes without going through the
same amount of hassle you would with a several hundred node farm.  Renderfarm
is invoked transparently for all file-&gt;render operations when it is enabled in
the preferences.
</p>
<p>Cinelerra divides the selected region of the timeline into a certain number of
jobs which are then dispatched to the different nodes depending on the load
balance.  The nodes process the jobs and write their output to individual files
on the filesystem.  The output files are not concatenated.  It is important for
all the nodes to have access to the same filesystem on the same mount point for
assets.
</p>
<p>If a node can not access an input asset it will display error messages to its
console but probably not die.  If it can not access an output asset it will cause
the rendering to abort.
</p>
<p>It should be noted that in the render dialog, the <b>Create new file at each
label</b> option causes a new renderfarm job to be created at each label instead
of by the load balancer.  If this option is selected when no labels exist, only
one job will be created.
</p>
<p>A Cinelerra renderfarm is organized into a master node and any number of slave
nodes.  The master node is the computer which is running the GUI.  The slave
nodes are anywhere else on the network and are run from the command line.  Run
a slave node from the command line with <code>cinelerra -d</code>
</p>
<p>That is the simplest configuration.  Type <code>cinelerra -h</code> to see more
options.  The default port number may be overridden by passing a port number
after the &lsquo;<samp>-d</samp>&rsquo;.
</p>
<p>Most of the time you will want to bring in the rendered output and fine tune the
timing on the timeline.  Also some file formats like MPEG can not be direct
copied.  Because of this, the jobs are left in individual files.
</p>
<p>You can load these by creating a new track and specifying <b>concatenate to
existing tracks</b> in the load dialog.  Files which support direct copy can be
concatenated into a single file by rendering to the same file format with
renderfarm disabled.  Also to get direct copy, the track dimensions, output
dimensions, and asset dimensions must be equal.
</p>
<p>MPEG files or files which do not support direct copy have to be concatenated
with a command line utility.  MPEG files can be concatenated with <b>cat</b>.
</p>
<p>Configuration of the renderfarm is described in the configuration chapter
See section <a href="cinelerra_cv_manual_en_3.html#Renderfarm">Renderfarm</a>.  The slave nodes traditionally read and write data to a
common filesystem over a network, thus they do not need hard drives.
</p>
<p>Ideally all the nodes on the renderfarm have similar CPU performance.
Cinelerra load balances on a first come first serve basis.  If the last segment
is dispatched to the slowest node, all the fastest nodes may end up waiting for
the slowest node to finish while they themselves could have rendered it faster.
</p>
<hr>
<a name="Command-line-rendering"></a>
<a name="Command-line-rendering-1"></a>
<h2 class="section">20.6 Command line rendering</h2>
<a name="index-Command-line-rendering"></a>
<a name="index-Rendering_002c-command-line"></a>

<p>The command line rendering facility consists of a way to load the current set
of batch rendering jobs and process them without a GUI.  This is useful if
you are planning on crashing X repeatedly or want to do rendering on the other
side of a low bandwidth network.  You might have access to a supercomputer in
India but still be stuck in America, exiled you might say.  A command line
interface is ideal for this.
</p>
<p>To perform rendering from the command line, first run Cinelerra in graphical
mode.  Go to <b>file-&gt;batch render</b>.  Create the batches you intend to render
in the batch window and close the window.  This saves the batches in a file.
Set up the desired renderfarm attributes in <b>settings-&gt;preferences</b> and exit
Cinelerra.  These settings are used the next time command line rendering is
used.
</p>
<p>On the command line run: <code>cinelerra -r</code>
</p>
<p>to processes the current batch jobs without a GUI.  Setting up all the
parameters for this operation is hard.  That is why the command line aborts if
any output files already exist.
</p>
<p>Other parameters exist for specifying alternative files for the preferences and
the batches.  Attempting to use anything but the defaults is very involved so
it has not been tested.
</p>
<hr>
<a name="Rendering-videos-for-the-internet"></a>
<a name="Rendering-videos-for-the-internet-1"></a>
<h2 class="section">20.7 Rendering videos for the internet</h2>
<a name="index-Rendering-videos-for-the-internet"></a>


<p>If you want to encode a video in order to put it on the internet, we recommend
to render it as a Quicktime4linux file, and then encode that file in MPEG4 of
FLV formats.  The Quicktime4linux file rendered from Cinelerra must have the
following properties:
</p>
<ul>
<li> Audio option Two Complements 16bits (PCM)
</li><li> Video option DV
</li></ul>

<hr>
<a name="Encoding-a-video-in-MPEG4-format-for-the-internet"></a>
<a name="Encoding-a-video-in-MPEG4-format-for-the-internet-1"></a>
<h3 class="subsection">20.7.1 Encoding a video in MPEG4 format for the internet</h3>
<a name="index-Encoding-a-video-in-MPEG4-format-for-the-internet"></a>

<p>To get the best quality, you should encode your Quicktime4linux file with
mencoder in two passes.
</p>
<p><b>First pass:</b>
</p><pre class="verbatim">mencoder input.mov -ovc xvid -xvidencopts bitrate=600:pass=1 \
-vf scale=320:240 -oac mp3lame -lameopts abr:br=64 -o output.avi
</pre><p><b>Second pass:</b>
</p><pre class="verbatim">mencoder input.mov -ovc xvid -xvidencopts bitrate=600:pass=2 \
-vf scale=320:240 -oac mp3lame -lameopts abr:br=64 -o output.avi
</pre><p>Do not forget to change the output size of the video, set with the &lsquo;<samp>-vf
scale=</samp>&rsquo; option.<br>
</p>
<p>Here are some other command lines.  They give output video files whose weight
is around 13 Mb for 3 minutes.<br>
<b>First pass:</b>
</p><pre class="verbatim">mencoder -oac pcm -sws 2 -vf scale=${width}:${height},hqdn3d=2:1:2 \
-ovc lavc -lavcopts vcodec=mpeg4:vbitrate=${video_bitrate}:vlelim=-4:\
vcelim=7:lumi_mask=0.05:dark_mask=0.01:scplx_mask=0.3:naq:v4mv:mbd=2:\
trell:cmp=3:subcmp=3:mbcmp=3:aspect=4/3:sc_threshold=1000000000:\
vmax_b_frames=2:vb_strategy=1:dia=3:predia=3:cbp:mv0:preme=2:\
last_pred=3:vpass=1:cgop -ofps 25 -of avi movie.mov -o /dev/null\
-ffourcc DIVX
</pre><p><b>Second pass:</b>
</p><pre class="verbatim">mencoder -srate 32000 -oac mp3lame -lameopts cbr:br=${audio_bitrate}:\
aq=0 -sws 2 -vf scale=${width}:${height},hqdn3d=2:1:2 -ovc lavc\
-lavcopts vcodec=mpeg4:vbitrate=${video_bitrate}:vlelim=-4:vcelim=7:\
lumi_mask=0.05:dark_mask=0.01:scplx_mask=0.3:naq:v4mv:mbd=2:trell:\
cmp=3:subcmp=3:mbcmp=3:aspect=4/3:sc_threshold=1000000000:\
vmax_b_frames=2:dia=3:predia=3:cbp:mv0:preme=2:last_pred=3:vpass=3:\
cgop -ofps 25 -of avi movie.mov -o movie.avi -ffourcc DIVX
</pre>
<p>You probably have to adapt those command lines if your material is noisy; have
a look at mencoder&rsquo;s pre-processing filters.  The *_mask parameters are really
important when encoding at low bitrate.<br>
</p>
<p>If you want your video file to be displayed properly on a well know media
player which runs on Windows you should be aware that:
</p><ul>
<li> the aspect ratio information contained in the AVI header will not be
taken into account by that player.  That is why you must scale the image to the
right aspect ratio.  Width and height must be multiples of 16.  Those are the
recommended resolutions for 4/3 PAL material: 384:288, 448:336, 512:384 or
704:528.
</li><li> the media player running on Windows will loose A/V sync if a VBR audio
bitrate is used instead of CBR.
</li><li> the &lsquo;<samp>-ffourcc</samp>&rsquo; parameter is needed for the video codec to be
recognized as Divx.
</li></ul>

<hr>
<a name="Encoding-a-video-in-FLV-format-for-the-internet"></a>
<a name="Encoding-a-video-in-FLV-format-for-the-internet-1"></a>
<h3 class="subsection">20.7.2 Encoding a video in FLV format for the internet</h3>
<a name="index-Encoding-a-video-in-FLV-format-for-the-internet"></a>

<p>FLV files (FLash Video) weight is very small and the only thing needed to play
those files is an internet browser with flash plugin version 7 or higher
installed.  That format is really useful when one wants to share a video with a
wide audience over the internet.
</p>
<p><b>First pass:</b>
</p><pre class="verbatim">ffmpeg -i movie.mov -b 430k -s 320x240 -aspect 4:3 -pass 1 -ar 22050 movie.flv
</pre><p><b>Second pass:</b>
</p><pre class="verbatim">ffmpeg -i movie.mov -b 430k -s 320x240 -aspect 4:3 -pass 2 -ar 22050 movie.flv
</pre>
<p>Pay attention to the output file extension.  Ffmpeg uses it to determine the
output format.  The audio sampling frequency to use is 22050 and the
&lsquo;<samp>-ar</samp>&rsquo; parameter must be used for the video to be properly encoded.
Ffmpeg does not write metadata information in the flv file.  The duration has to
be written in the metadata information in order for some flash players to
display a progress bar.  FLVTool2 (<a href="http://www.inlet-media.de/flvtool2">http://www.inlet-media.de/flvtool2</a>)
can be used to insert that information:
</p><pre class="verbatim">cat input_file.flv | flvtool2 -U stdin output_file.flv
</pre>
<p>There are a number of options for embedding the flv file in a web page. 
You can use ming or flv2swf to create an swf file. <br>
<a href="http://klaus.geekserver.net/flash/streaming.html">http://klaus.geekserver.net/flash/streaming.html</a> has detailed instructions 
for ming and <a href="http://search.cpan.org/~clotho/FLV-Info-0.17/bin/flv2swf">http://search.cpan.org/~clotho/FLV-Info-0.17/bin/flv2swf</a> 
can be installed with cpan&gt; install FLV::ToSWF. Or you can use the Creative Commons 
Non-Commercial licensed JW FLV Player
<a href="http://www.jeroenwijering.com/?item=JW_FLV_Player">http://www.jeroenwijering.com/?item=JW_FLV_Player</a>, or the Apache licensed
FlowPlayer <a href="http://flowplayer.org">http://flowplayer.org</a>. Both of these allow you to use the flv 
as created above, and have controls for stopping and playing the movie etc.
</p>
<hr>
<a name="Quicktime-for-GNU_002fLinux-compatibility-chart"></a>
<a name="Quicktime-for-GNU_002fLinux-compatibility-chart-1"></a>
<h2 class="section">20.8 Quicktime for GNU/Linux compatibility chart</h2>
<a name="index-Quicktime-for-GNU_002fLinux-compatibility-chart"></a>

<p>Scott Frase wrote a Quicktime for GNU/Linux compatibility chart.  It contains an
exhaustive list of all the Quicktime compression schemes available and their
compatibility in Cinelerra, Mplayer and some other media players.  That
document has two main sections, one based on an HDV resolution-formatted
project and another based on a DV resolution-format project.
</p>
<p>It is available here:<br>
<a href="http://content.serveftp.net/video/qtcompatibility.ods">http://content.serveftp.net/video/qtcompatibility.ods</a>
</p>
<p>Some interesting notes:
</p><ul>
<li> Mplayer does behave better with smaller, DV resolution video
</li><li> Cinelerra compatibility with files rendered from a DV project is not much
different than its compatibility with files rendered from an HDV project.
</li><li> Comparison chart of DV/HDV mplayer/cinelerra compatibility included
</li></ul>

<hr>
<a name="Making-a-DVD"></a>
<a name="Making-a-DVD-1"></a>
<h2 class="section">20.9 Making a DVD</h2>
<a name="index-Making-a-DVD"></a>
<a name="index-DVD_002c-making-a"></a>


<hr>
<a name="Rendering-to-mpeg2"></a>
<a name="Rendering-to-mpeg2-1"></a>
<h3 class="subsection">20.9.1 Rendering to mpeg2</h3>
<a name="index-Rendering-to-mpeg2"></a>
<a name="index-Mpeg2_002c-rendering-to"></a>


<p>Here is a method to export mpeg2 video for DVD.
This method allows you to precisely set the encoding option you want and produces an
mpeg2 file which is 100% compatible with all DVD standalone players.
For how to make a DVD from the output See section <a href="#Authoring-a-DVD">Authoring a DVD</a>.
</p>
<p>Audio and video are rendered separately and combined later in a procedure external
to Cinelerra. <br>
<b>Audio</b> is rendered into <b>.ac3</b>, and <b>video</b> is rendered into a
<b>yuv4mpeg stream</b> which is piped through either <b>mpeg2enc</b> or <b>ffmpeg</b> into a 
<b>.m2v</b> file. Both variants are described in detail below. 
</p>
<p>(Apparently depending on footage and player engine, one or the other variant may 
produce better results. Check out which one works best for you by rendering a short 
test edit of a few seconds length, authoring to DVD according to the sections below, 
and playing it in your cheapest standalone player to really see wether it is foolproof 
or displays errors.) 
</p>	 
<p>In both cases, make sure you properly defined your Cinelerra project format before 
rendering your video (menu <b>Settings-&gt;Format...</b>), preferably even before loading 
any raw footage. <br>
<b>TV standards:</b><br>
<b>PAL</b> is 720x576 at 25 frames per second, <br>
<b>NTSC</b> is 720x480 at 29.97 frames per second.
</p>
<hr>
<a name="yuv4mpeg-pipe-through-mpeg2enc"></a>
<a name="yuv4mpeg-pipe-through-mpeg2enc-1"></a>
<h4 class="subsubsection">20.9.1.1 yuv4mpeg pipe through mpeg2enc</h4>
<a name="index-yuv4mpeg-pipe-through-mpeg2enc"></a>
<a name="index-mpeg2enc_002c-yuv4mpeg-pipe"></a>

<p>The mplex program from <b>mjpegtools</b> must be installed.  The mjpegtools
package is built in the hvirtual distribution and the mplex utility may be
extracted from there.
</p>
<ol>
<li> Create a script &lsquo;<tt>~/cine_render.sh</tt>&rsquo;
</li><li> Copy in &lsquo;<tt>~/cine_render.sh file</tt>&rsquo; the following lines:<br>
<code>#/bin/bash</code><br>
<code>mpeg2enc -v 0 -K tmpgenc -r 16 -4 1 -2 1 -D 10 -E 10 -g 15 -G 15 -q 6
-b 8600 -f 8 -o $1</code>
</li><li> Put the execute permissions on that file:
<code>chmod 777 ~/cine_render.sh</code>
</li><li> Within Cinelerra, and select the part of the project you want to render with
the [ and ] points
</li><li> Press <kbd>SHIFT-R</kbd>
</li><li> Select the <b>YUV4MPEG Stream</b> file format
</li><li> Deselect <b>Render audio tracks</b> and select <b>Render video tracks</b>
</li><li> Click on the wrench
</li><li> In the newly opened window, indicate the name of the &lsquo;<tt>m2v</tt>&rsquo; file you
want to create.  That file will contain video only.
</li><li> Click on <b>Use pipe</b> and write this command:
<code>/home/&lt;your_user&gt;/cine_render.sh %</code>
</li><li> Click OK to close the second window, and OK again to render your
&lsquo;<tt>m2v</tt>&rsquo; file
</li><li> When the m2v file is rendered, open the rendering window again, and
render an AC3 file at 224kbits
</li><li> Finally, combine video and audio with this command:<br>
<code>mplex -f 8 your_video_file.m2v your_audio_file.ac3 -o
video_audio_file.mpeg</code><br>
If you obtain errors while using mplex, increase the quantizer (&lsquo;<samp>-q</samp>&rsquo;
option, see below).
</li></ol>

<p>You can modify the mpeg2enc parameters if you want to.  Look at the mpeg2enc
manpage.  Some details about the settings:
</p><ul>
<li> &lsquo;<samp>-b 8600</samp>&rsquo; : This is the maximum bitrate of your &lsquo;<tt>m2v</tt>&rsquo; file (it
does not include the audio bitrate).  We recommend you to do not increase that
value or you could get errors when mplexing the video and the audio.
</li><li> &lsquo;<samp>-q 6</samp>&rsquo; : This is the quantizer setting.  If you reduce it (do not go
below 3), the quality increases.  But the bitrate will increase.  It&rsquo;s
recommended to keep the medium bitrate achieved (that&rsquo;s displayed when mplexing
the audio and video files) around 10% lower than the bitrate defined with the
&lsquo;<samp>-b</samp>&rsquo; setting.
</li><li> &lsquo;<samp>-K tmpgenc</samp>&rsquo; : invokes the TMPGEnc matrices.  It reduces the
average bitrate by about 10% compared to the default tables.  For very-high
quality material, you can try removing this option.
</li></ul>

<p>If your material is noisy (Hi8 analog material for example), you can add some
mjpegtools in the command line written in &lsquo;<tt>~/cine_render.sh</tt>&rsquo;:
</p><ul>
<li> <code>y4mshift</code> and <code>y4mscaler</code> can be used to remove the
noisy borders around the video.  For example, those commands added at the
beginning of the command line in &lsquo;<tt>cine_render.sh</tt>&rsquo; remove the black borders
around a Hi8 video:<br>
<code>yuvscaler -v 0 -I ACTIVE_700x560+8+8 | y4mshift -n 2 |</code>
</li><li> <code>yuvdenoise</code> and <code>yuvmedianfilter</code> can help removing
noise.  Example:<br>
<code>yuvdenoise -F | yuvmedianfilter -T 3 |</code><br>
Denoising is a complex task, and the options given above are just an example.
Please read the mjpegtools&rsquo;manual and subscribe to its mailing-list for more
information.
</li></ul>

<hr>
<a name="yuv4mpeg-pipe-through-ffmpeg"></a>
<a name="yuv4mpeg-pipe-through-ffmpeg-1"></a>
<h4 class="subsubsection">20.9.1.2 yuv4mpeg pipe through ffmpeg</h4>
<a name="index-yuv4mpeg-pipe-through-ffmpeg"></a>

<ol>
<li> Select <b>File-&gt;Render...</b> or press &lt;SHIFT-R&gt;. The render dialog pops up. 
</li><li> In the render dialog, you have the choice to render 1. the entire project, or 
2. the highlighted selection, or 3. from In-point &quot;[&quot; to Out-point &quot;]&quot;.
</li><li> Make sure the <b>Insertion strategy</b> is &quot;Create new resources only&quot;.
</li><li> Select the <b>AC3</b> audio output file format.
</li><li> Specify the audio output file name and path (example:
<code>your-movie.ac3</code>).
</li><li> Select <b>Render audio tracks</b> and deselect <b>Render video tracks</b>.
</li><li> Click on the wrench next to &quot;Audio:&quot;. A new dialog &quot;Cinelerra: Audio Compression&quot; 
pops up.
</li><li> Set the bitrate to <b>128 kbps</b> (or leave it there).
</li><li> Click OK, the compression dialog disappears.
</li><li> In the render dialog, click OK, the dialogu disappears. Audio is rendered. 
Rendering audio is much faster than rendering video but might still take some seconds. 
Watch the progress bar in the main window&rsquo;s lower right corner.
</li><li> Again, press &lt;SHIFT-R&gt;. The render dialog pops up again.
</li><li> Select the <b>YUV4MPEG Stream</b> file format.
</li><li> Specify the video output file name and path (example:
<code>your-movie.m2v</code>).
</li><li> Deselect <b>Render audio tracks</b> and select <b>Render video tracks</b>.
</li><li> Click on the wrench next to &quot;Video:&quot;. A new dialog window &quot;Cinelerra: YUV4MPEG 
stream&quot; pops up. The first textbox should already contain the output filename and path 
you had specified in the render dialog.
</li><li> Select &quot;Use Pipe:&quot;.
</li><li> Fill the following command line into the second textbox: <br>
<code>ffmpeg -f yuv4mpegpipe -i - -y -target dvd -flags +ilme+ildct %</code>
</li><li> Click OK in the yuv4mpeg dialog and in the render dialog to render video output.
</li><li> The resulting .m2v can be further processed together with the .ac3 audio with 
the following shell command, producing a dvd-compatible mpeg stream:<br>
<code>ffmpeg -i your-movie.ac3 -i your-movie.m2v -target dvd -flags
+ilme+ildct your-movie.mpg</code> (Yes, the stream is sent through ffmpeg a second time.)
</li></ol>

<p>Note on ffmpeg command line options:<br>
<code>-i</code> tells ffmpeg to read from standard input (in our pipe, this means from 
Cinelerra&rsquo;s render stream).<br>
The <code>-y</code> option allows to overwrite existing target files (of course, it is 
safer to omit this, but then you must make sure to rename or delete previous results 
each time you want to render a new version).<br>
The <code>+ilme+ildct</code> flags are for proper interlacing, bottom fields first, tested 
with PAL footage. Some Cinelerra versions suggest a similar command line in the ffmpeg 
pipe presets for DVD, however with erroneous syntax of the interlacing flags or 
without the flags.
</p>
<p>Before proceeding to put your rendered mpeg2 data on DVD, you might want to watch and 
check your-movie.mpg in mplayer or xine/kaffeine.
</p>			
<hr>
<a name="Making-a-DVD-menu"></a>
<a name="Making-a-DVD-menu-1"></a>
<h3 class="subsection">20.9.2 Making a DVD menu</h3>
<a name="index-Making-a-DVD-menu"></a>

<p>A DVD menu is composed of:
</p>
<ul>
<li> a background (still image or video)
</li><li> buttons
</li><li> sound/music
</li></ul>

<p>You can build a menu with a GUI such as qdvdauthor, dvdstyler, dvdwizard or
tovid.  However, using those GUI is not perfect for the moment, since they are
bugged or limited for the moment.
</p>
<p>If you prefer to use a GUI, we recommend you to try tovid:<br>
<a href="http://tovid.wikia.com/wiki/Main_Page">http://tovid.wikia.com/wiki/Main_Page</a><br>
QDVDAuthor contained a lot of bugs sometime ago, but its author fixed some of
them recently, which makes QDVDAuthor more usable.
</p>
<p>The method we explain below is more complicated than using a GUI, however it:
</p>
<ul>
<li> produces DVD playable on all standalone players
</li><li> is not subject to bugs
</li><li> will save you a lot of time since all you have to do to author a new DVD
is to modify text files
</li></ul>

<p>Here are the steps needed to create your DVD menu:
</p>
<ul>
<li> create the menu background with cinelerra
</li><li> add the buttons by creating PNG images
</li><li> combine the menu and the buttons with spumux
</li></ul>

<p>We suppose that you want to create a menu with an animated background.  Launch
Cinelerra and create a project containing what you want to be the background of
the menu.  You can add a music if you wish to.  Pay attention to the fact that
this menu will play in loop.
</p>
<p>To draw the buttons, you have two possibilities:
</p>
<ul>
<li> display them in Cinelerra.  That way, you will be able to make animated
buttons, such as a video thumbnail for each part of your video.
</li><li> do not draw the buttons in Cinelerra.  You will add them later on, from
PNG images &quot;added&quot; to the mpeg2 menu file.  This is the simplest method, but
you won&rsquo;t be able to display animated buttons.
</li></ul>

<p>Render that video into m2v and ac3 using the <code>cine_render.sh</code> method
explain above.  Combine the audio and video with mplex as you would do with any
&quot;normal&quot; video.
</p>
<p>You obtain a mpeg2 file containing the menu background, and some buttons
displayed above it if you added them in Cinelerra.
</p>
<p>We have to use spumux to define each button position in that mpeg2 file.  If
you did not draw the buttons in Cinelerra, you will be able to put them in with
spumux.
</p>
<p>Spumux is a command line utility which takes 2 arguments:
</p>
<ul>
<li> an XML file explaining where the buttons are
</li><li> the mpeg2 file name (the one you rendered for the menu)
</li></ul>

<p>Here is a spumux example XML file:
</p><pre class="verbatim">&lt;subpictures&gt;
 &lt;stream&gt;
  &lt;spu start=&quot;00:00:00.0&quot; image=&quot;buttons_normal.png&quot; highlight=
  &quot;buttons_highlight.png&quot; select=&quot;buttons_select.png&quot;&gt;
   &lt;button name=&quot;1&quot; x0=&quot;94 &quot; y0=&quot;234 &quot; x1=&quot;253 &quot; y1=&quot;278&quot;
   down=&quot;2&quot; right=&quot;4&quot; /&gt;
   &lt;button name=&quot;2&quot; x0=&quot;63 &quot; y0=&quot;287 &quot; x1=&quot;379 &quot; y1=&quot;331&quot; up=&quot;1&quot;
   down=&quot;3&quot; right=&quot;5&quot; /&gt;
  &lt;/spu&gt;
 &lt;/stream&gt;
&lt;/subpictures&gt;
</pre>
<ul>
<li> <b>image=&quot;buttons_normal.png&quot;</b> This png image contains the buttons as
they should appear when they are not selected nor highlighted.
</li><li> <b>highlight=&quot;buttons_highlight.png&quot;</b> This png image contains the buttons
in their highlighted state.
</li><li> <b>select=&quot;buttons_select.png</b> This png image contains the buttons in
their selected state.
</li></ul>

<p>If you already made the buttons in Cinelerra, you have to specify empty (100%
transparent) PNG images here.
</p>
<p>The PNG images used in spumux must:
</p>
<ul>
<li> contain an <b>alpha channel</b> (ie support transparency)
</li><li> be in <b>4 indexed colors</b>.  You can easily convert an image to 4 indexed
colors using Gimp.
</li></ul>

<p>There is one line per button.  Each line contains the button coordinates, a
button having a rectangular shape:
</p>
<ul>
<li> <b>x0, y0</b>: upper left corner
</li><li> <b>x1, y1</b>: bottom right corner
</li></ul>

<p>You also have to set which button to move to when using the up, down, left and
right buttons of the DVD remote.  Here is an example:
</p>
<pre class="verbatim">&lt;button name=&quot;3&quot; ...coordinates... up=&quot;1&quot; down=&quot;5&quot; left=&quot;2&quot; right=&quot;4&quot; /&gt;
</pre>
<p>When button 3 is selected, if the &quot;Up&quot; key is pressed on the remote then the
button 1 will be highlighted.  If the &quot;Right&quot; key is pressed on the remote,
then button 4 will be highlighted.
</p>
<p>When you have finished editing your spumux XML file, you have to type this
command:<br>
<code>spumux menu.xml &lt; menu.mpeg &gt; menu_with_buttons.mpeg</code><br>
That will make a &lsquo;<tt>menu_with_buttons.mpeg</tt>&rsquo;.  It is an mpeg2 files with
buttons.
</p>
<hr>
<a name="Authoring-a-DVD"></a>
<a name="Authoring-a-DVD-1"></a>
<h3 class="subsection">20.9.3 Authoring a DVD</h3>
<a name="index-Authoring-a-DVD"></a>

<p>After having rendered to mpeg2 your video files, and having prepared a menu
with spumux, you need to &quot;author&quot; the DVD with dvdauthor, that is another command line
application.
</p>
<p>dvdauthor uses XML files to describe the DVD structure. You need to create an
XML file in a text editor and save it as &lsquo;<tt>simple_example.xml</tt>&rsquo; in the same folder 
of your &lsquo;<tt>/the/mpeg/file.mpeg</tt>&rsquo; mpeg2 video file.
You should really pay a lot of attention to the .xml file syntax since it is very rigorous.
The risk is the DVD to be readable on some standalone players, but not on all of them.
</p>
<p>To help you start using dvdauthor, here are some example XML files you can copy
and paste into your &lsquo;<tt>simple_example.xml</tt>&rsquo; file. Replace example filenames
and paths with the ones right for your project.
</p>
<pre class="verbatim">&lt;dvdauthor dest=&quot;/path/to/the/folder/which/will/contain/the/dvd&quot;&gt;
    &lt;vmgm /&gt;
    &lt;titleset&gt;
        &lt;titles&gt;
            &lt;pgc&gt;
                &lt;vob file=&quot;/the/mpeg/file.mpeg&quot; /&gt;
	        	&lt;post&gt;
                    jump chapter 1;
                &lt;/post&gt;
            &lt;/pgc&gt;
        &lt;/titles&gt;
    &lt;/titleset&gt;
&lt;/dvdauthor&gt;
</pre>
<p>This is a very simple dvdauthor XML file.  There are no menus, so the video file
&lsquo;<tt>/the/mpeg/file.mpeg</tt>&rsquo; will be played as soon as you insert the DVD in the
player.
</p>
<p>The command in &lt;post&gt; tag means the video should be played in a loop.  When the
DVD player reaches the end of the video, it will jump to the first chapter of
the video (which dvdautor assumes to be the beginning of the video since
chapters haven&rsquo;t been defined).
To make the video play only once without jumping from the end to the beginning,
remove the following lines from your XML file.
</p><pre class="verbatim">            	&lt;post&gt;
                    jump chapter 1;
                &lt;/post&gt;
</pre>
<p>To author the DVD, go to the folder that contains the video and the XML file and type the following command:<br>
<code>dvdauthor -x simple_example.xml</code>
</p>
<p>Now, let&rsquo;s have a look at a more complex example.  When the DVD is inserted, a
menu is displayed and you can choose to play any of 4 videos.
</p>
<pre class="verbatim">&lt;dvdauthor dest=&quot;/path/to/the/folder/which/will/contain/the/dvd&quot; jumppad=&quot;yes&quot; &gt;
&lt;vmgm&gt;
 &lt;fpc&gt; jump menu 1; &lt;/fpc&gt;
  &lt;menus&gt;
   &lt;video format=&quot;pal&quot; aspect=&quot;4:3&quot; resolution=&quot;720x576&quot; /&gt;
   &lt;pgc entry=&quot;title&quot; &gt;
    &lt;vob file=&quot;menu.mpeg&quot; pause=&quot;0&quot; /&gt;
    &lt;button name=&quot;1&quot; &gt; { g3=1; jump titleset 1 menu entry root; } &lt;/button&gt;
    &lt;button name=&quot;2&quot; &gt; { g3=2; jump titleset 1 menu entry root; } &lt;/button&gt;
    &lt;button name=&quot;3&quot; &gt; { g3=3; jump titleset 1 menu entry root; } &lt;/button&gt;
    &lt;button name=&quot;4&quot; &gt; { g3=4; jump titleset 1 menu entry root; } &lt;/button&gt;
     &lt;post&gt; { jump cell 1; } &lt;/post&gt;
   &lt;/pgc&gt;
  &lt;/menus&gt;
 &lt;/vmgm&gt;
 &lt;titleset&gt;
  &lt;menus&gt;
   &lt;pgc entry=&quot;root&quot; &gt;
    &lt;pre&gt; { if ( g3 gt 0 )  {
		if ( g3 eq 1 ) { g3=0; jump title 1  chapter 1; }
		if ( g3 eq 2 ) { g3=0; jump title 1  chapter 3; }
		if ( g3 eq 3 ) { g3=0; jump title 1  chapter 5; }
		if ( g3 eq 4 ) { g3=0; jump title 1  chapter 7; }
		jump vmgm menu entry title;
		}
	} &lt;/pre&gt;
    &lt;post&gt; { jump vmgm menu entry title; } &lt;/post&gt;
   &lt;/pgc&gt;
  &lt;/menus&gt;
  &lt;titles&gt;
   &lt;video format=&quot;pal&quot; aspect=&quot;4:3&quot; resolution=&quot;720x576&quot; /&gt;
   &lt;pgc pause=&quot;0&quot; &gt;
    &lt;vob file=&quot;video_1.mpeg&quot; pause=&quot;0&quot; /&gt;
    &lt;vob file=&quot;blackvideo.mpg&quot; pause=&quot;0&quot; /&gt;
    &lt;vob file=&quot;video_2.mpeg&quot; pause=&quot;0&quot; /&gt;
    &lt;vob file=&quot;blackvideo.mpg&quot; pause=&quot;0&quot; /&gt;
    &lt;vob file=&quot;video_3.mpeg&quot; pause=&quot;0&quot; /&gt;
    &lt;vob file=&quot;blackvideo.mpg&quot; pause=&quot;0&quot; /&gt;
    &lt;vob file=&quot;video_4.mpeg&quot; pause=&quot;0&quot; /&gt;
    &lt;post&gt; { call vmgm menu entry title; } &lt;/post&gt;
   &lt;/pgc&gt;
  &lt;/titles&gt;
 &lt;/titleset&gt;
&lt;/dvdauthor&gt;
</pre>
<p>The file &lsquo;<tt>blackvideo.mpg</tt>&rsquo; is used to add a 2 second black screen between
each video.  Here is how to create it:<br>
<code>convert -size 720x576 xc:black -depth 8 blackframe.ppm</code><br>
<code>dd if=/dev/zero bs=4 count=960000 | toolame -b 128 -s 48 /dev/stdin
emptyaudio.mpa</code><br>
<code>ppmtoy4m -S 420mpeg2 -n 50 -F 25:1 -r blackframe.ppm | mpeg2enc -a 2
-n p -f 8 -o blackvideo.mpv</code><br>
<code>mplex -f 8 -o blackvideo.mpg blackvideo.mpv emptyaudio.mpa</code>
</p>
<hr>
<a name="Burning-a-DVD"></a>
<a name="Burning-a-DVD-1"></a>
<h3 class="subsection">20.9.4 Burning a DVD</h3>
<a name="index-Burning-a-DVD"></a>

<p>When you have finished authoring the DVD, you will find in the destination folder the
following directories: &lsquo;<tt>AUDIO_TS</tt>&rsquo; and &lsquo;<tt>VIDEO_TS</tt>&rsquo;.  To test your DVD
before burning it, cd into this folder, and type:<br>
<code>xine dvd:`pwd`</code>
</p>
<p>If your DVD plays fine on your computer, it is time to burn it.  When you are
in the folder containing &lsquo;<tt>AUDIO_TS</tt>&rsquo; and &lsquo;<tt>VIDEO_TS</tt>&rsquo;, type this
command (adjusting for your dvd burner device, eg /dev/dvdrw):<br>
<code>nice -n -20 growisofs -dvd-compat -speed=2 -Z /dev/dvd -dvd-video -V
VIDEO ./ &amp;&amp; eject /dev/dvd</code>
</p>
<p>If you have a lot of copies to do, you can first make an .iso master in the
parent folder using this command:<br>
<code>nice -n -20 mkisofs -dvd-video -V VIDEO -o ../dvd.iso .</code><br>
This &lsquo;<tt>../dvd.iso</tt>&rsquo; file can be burnt using this command:<br>
<code>nice -n -20 growisofs -dvd-compat -speed=2 -Z /dev/dvd=../dvd.iso &amp;&amp;
eject /dev/cdrom</code>
</p>
<p>We recommend you do not burn at a speed higher than 4x.  Use good quality DVD-R
only.
</p>
<p>To test your DVD on a standalone player without wasting several DVD-R, you can
burn on DVD-RW.  First, format your DVD-RW using this command:<br>
<code>dvd+rw-format -lead-out /dev/dvd</code><br>
Then, burn the DVD-RW using the commands above.
</p>
<hr>
<a name="Using-background-rendering"></a>
<a name="Using-background-rendering-1"></a>
<h2 class="section">20.10 Using background rendering</h2>
<a name="index-Background-rendering-1"></a>
<a name="index-Rendering_002c-background-1"></a>

<p>Background rendering allows impossibly slow effects to play back in real-time
shortly after the effect is pasted in the timeline.  It continuously renders
temporary output.  When renderfarm is enabled, background rendering uses the
renderfarm continuously.  This way, any size video can be seen in real-time
merely by creating a fast enough network with enough nodes.
</p>
<p>Background rendering is enabled in settings-&gt;preferences-&gt;performance.  It has
one interactive function: <b>settings-&gt;set background render</b>.  This sets the
point where background rendering begins to where the in point is.  If any video
exists, a red bar appears in the timeline showing what has been background
rendered.
</p>
<p>It is often useful to insert an effect or a transition and then select
settings-&gt;set background render right before the effect to preview it at full
framerates.
</p>
<hr>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Rendering-files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_21.html#Tips" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="cinelerra_cv_manual_en_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated on <i>May 12, 2015</i> using <a href="http://www.nongnu.org/texi2html/"><i>texi2html 5.0</i></a>.
 </font>
 <br>

</p>
</body>
</html>
